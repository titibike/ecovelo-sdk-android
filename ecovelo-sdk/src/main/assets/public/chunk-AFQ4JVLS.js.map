{
  "version": 3,
  "sources": ["src/app/services/internal/launch.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core'\nimport { firstValueFrom } from 'rxjs'\nimport {\n  ProgramsService,\n  ZonesService,\n  ListZone200Response,\n} from 'src/api-cyclist'\nimport { StationWrapperService } from '../api-wrappers/stations.service'\nimport { NewsStateService } from '../api-wrappers/news.service'\nimport { ForfaitsWrapperService } from '../api-wrappers/forfaits.service'\nimport { KYCWrapperService } from '../api-wrappers/kyc.service'\nimport { PersonnalisationService } from '../utils/personnalisation.service'\nimport { StorageService } from '../utils/storage.service'\nimport { environment } from 'src/environments/environment'\nimport { ErrorHandlerService } from '../utils/error-handler.service'\n\nexport interface LaunchOptions {\n  skipIfDataExists?: boolean\n  forceRefreshStations?: boolean\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class LaunchService {\n  constructor(\n    private programsService: ProgramsService,\n    private zonesService: ZonesService,\n    private stationWrapperService: StationWrapperService,\n    private newsStateService: NewsStateService,\n    private forfaitService: ForfaitsWrapperService,\n    private kycService: KYCWrapperService,\n    private personnalisationService: PersonnalisationService,\n    private storageService: StorageService,\n    private errorHandler: ErrorHandlerService\n  ) {}\n\n  /**\n   * Load all essential app data with retry logic\n   */\n  async loadEssentialData(options: LaunchOptions = {}): Promise<void> {\n    // Check if essential data already exists in storage\n    if (options.skipIfDataExists) {\n      const existingProgram = await this.storageService.get('program')\n      const existingZones = await this.storageService.get('zones')\n      const existingForfaits = await this.storageService.get('forfaits')\n      const existingStations = await this.storageService.get('stations')\n\n      if (\n        existingProgram &&\n        existingZones &&\n        existingForfaits &&\n        existingStations\n      ) {\n        // Still set colors and title from existing program\n        this.personnalisationService.setColors()\n        this.personnalisationService.setTitle()\n        this.kycService.setKycDocumentTypes()\n        return\n      }\n    }\n\n    const retryOperation = async (\n      operation: () => Promise<any>,\n      name: string,\n      maxRetries = 3\n    ) => {\n      for (let i = 0; i < maxRetries; i++) {\n        try {\n          return await operation()\n        } catch (error) {\n          if (i === maxRetries - 1) {\n            console.error(`Final retry failed for ${name}:`, error)\n            throw error\n          }\n          console.warn(\n            `Retry ${i + 1}/${maxRetries} for ${name} after error:`,\n            error\n          )\n          await new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1))) // Exponential backoff\n        }\n      }\n    }\n\n    try {\n      const operations = []\n\n      // Check what needs to be loaded\n      const existingProgram = await this.storageService.get('program')\n      const existingZones = await this.storageService.get('zones')\n\n      // Only load what's missing or requested\n      if (!existingProgram || !options.skipIfDataExists) {\n        operations.push(retryOperation(() => this.loadProgram(), 'loadProgram'))\n      }\n\n      // Always refresh stations (they change frequently)\n      operations.push(\n        retryOperation(\n          () => this.loadStations(options.forceRefreshStations),\n          'loadStations'\n        )\n      )\n\n      if (!existingZones || !options.skipIfDataExists) {\n        operations.push(retryOperation(() => this.loadZones(), 'loadZones'))\n      }\n\n      // Always refresh news and forfaits\n      operations.push(\n        retryOperation(\n          () => this.newsStateService.retrieveNews(),\n          'retrieveNews'\n        ),\n        retryOperation(() => this.forfaitService.loadForfaits(), 'loadForfaits')\n      )\n\n      await Promise.all(operations)\n    } catch (error) {\n      this.errorHandler.handleError(error)\n      console.error('‚ùå LaunchService: Error loading essential data:', error)\n      // Don't throw here, some data might be optional\n    }\n  }\n\n  /**\n   * Load program configuration\n   */\n  private async loadProgram(): Promise<void> {\n    const program: any = await firstValueFrom(\n      this.programsService.retrieveProgram({\n        program: environment.program,\n        expand: ['config'],\n      })\n    )\n\n    if (program.config?.kyc_document_types) {\n      this.kycService.kyc_document_types.set(program.config.kyc_document_types)\n    }\n\n    await this.storageService.set('program', program)\n    this.personnalisationService.setColors()\n    this.personnalisationService.setTitle()\n    this.kycService.setKycDocumentTypes()\n  }\n\n  /**\n   * Load stations data\n   */\n  private async loadStations(forceRefresh: boolean = true): Promise<void> {\n    await this.stationWrapperService.refreshStations(forceRefresh)\n  }\n\n  /**\n   * Load zones data\n   */\n  private async loadZones(): Promise<void> {\n    const response: ListZone200Response = await firstValueFrom(\n      this.zonesService.listZone({\n        program: environment.program,\n        status: 'open',\n        liveMode: environment.production,\n        limit: 100,\n      })\n    )\n\n    const zonesToStore =\n      'zones' in response ? (response as any).zones : response\n    await this.storageService.set('zones', zonesToStore)\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
