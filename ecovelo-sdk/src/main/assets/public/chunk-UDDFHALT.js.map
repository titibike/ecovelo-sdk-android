{"version":3,"sources":["node_modules/@angular/core/fesm2022/rxjs-interop.mjs","node_modules/ngx-lottie/fesm2022/ngx-lottie.mjs"],"sourcesContent":["/**\n * @license Angular v19.2.15\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError as _RuntimeError, ɵgetOutputDestroyRef as _getOutputDestroyRef, Injector, effect, untracked, ɵmicrotaskEffect as _microtaskEffect, assertNotInReactiveContext, signal, computed, PendingTasks, resource } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  source;\n  destroyed = false;\n  destroyRef = inject(DestroyRef);\n  constructor(source) {\n    this.source = source;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new _RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi\n */\nfunction outputToObservable(ref) {\n  const destroyRef = _getOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\nfunction toObservableMicrotask(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = _microtaskEffect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  typeof ngDevMode !== 'undefined' && ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  let destroyUnregisterFn;\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    },\n    complete: () => {\n      destroyUnregisterFn?.();\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @experimental\n */\nfunction pendingUntilEvent(injector) {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n  return sourceObservable => {\n    return new Observable(originalSubscriber => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n        removeTask();\n        cleanedUp = true;\n      }\n      const innerSubscription = sourceObservable.subscribe({\n        next: v => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: e => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        }\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\nfunction rxResource(opts) {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource({\n    ...opts,\n    loader: undefined,\n    stream: params => {\n      let sub;\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n      // Start off stream as undefined.\n      const stream = signal({\n        value: undefined\n      });\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      function send(value) {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n      sub = opts.loader(params).subscribe({\n        next: value => send({\n          value\n        }),\n        error: error => {\n          send({\n            error\n          });\n          params.abortSignal.removeEventListener('abort', onAbort);\n        },\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new Error('Resource completed before producing a value')\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }\n  });\n}\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal, toObservableMicrotask as ɵtoObservableMicrotask };\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, ɵisPromise as _isPromise, Injectable, input, PLATFORM_ID, Directive, Output, ElementRef, Component, ChangeDetectionStrategy, ViewChild, makeStateKey } from '@angular/core';\nimport { from, of, Observable, Subject, BehaviorSubject, defer } from 'rxjs';\nimport { map, tap, shareReplay, mergeMap, filter, switchMap } from 'rxjs/operators';\nimport { isPlatformBrowser, NgStyle, NgClass } from '@angular/common';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nconst _c0 = [\"container\"];\nconst LOTTIE_OPTIONS = new InjectionToken('LottieOptions');\nfunction convertPlayerOrLoaderToObservable() {\n  const ngZone = inject(NgZone);\n  const {\n    player,\n    useWebWorker\n  } = inject(LOTTIE_OPTIONS);\n  const playerOrLoader = ngZone.runOutsideAngular(() => player());\n  // We need to use `isPromise` instead of checking whether\n  // `result instanceof Promise`. In zone.js patched environments, `global.Promise`\n  // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js\n  // for certain reasons, might not work with `instanceof`. For instance, the dynamic\n  // import `() => import('./chunk.js')` returns a native promise (not a `ZoneAwarePromise`),\n  // causing this check to be falsy.\n  const player$ = _isPromise(playerOrLoader) ? from(playerOrLoader).pipe(map(module => module.default || module)) : of(playerOrLoader);\n  return player$.pipe(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tap(player => player.useWebWorker?.(useWebWorker)), shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\nclass AnimationLoader {\n  constructor() {\n    this.player$ = convertPlayerOrLoaderToObservable().pipe(mergeMap(player => raf$(this.ngZone).pipe(map(() => player))));\n    this.ngZone = inject(NgZone);\n  }\n  loadAnimation(options) {\n    return this.player$.pipe(map(player => this.createAnimationItem(player, options)));\n  }\n  resolveOptions(options, container) {\n    return Object.assign({\n      container,\n      renderer: 'svg',\n      loop: true,\n      autoplay: true\n    }, options);\n  }\n  createAnimationItem(player, options) {\n    return this.ngZone.runOutsideAngular(() => player.loadAnimation(options));\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function AnimationLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AnimationLoader)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AnimationLoader,\n      factory: AnimationLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AnimationLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction raf$(ngZone) {\n  return new Observable(subscriber => {\n    const requestId = ngZone.runOutsideAngular(() => requestAnimationFrame(() => {\n      subscriber.next();\n      subscriber.complete();\n    }));\n    return () => cancelAnimationFrame(requestId);\n  });\n}\nclass CacheableAnimationLoader extends AnimationLoader {\n  constructor() {\n    super(...arguments);\n    this.cache = new Map();\n  }\n  ngOnDestroy() {\n    this.cache.clear();\n  }\n  loadAnimation(options) {\n    return this.player$.pipe(map(player => {\n      const animationItem = this.createAnimationItem(player, this.transformOptions(options));\n      this.awaitConfigAndCache(options, animationItem);\n      return animationItem;\n    }));\n  }\n  awaitConfigAndCache(options, animationItem) {\n    if (this.isAnimationConfigWithPath(options)) {\n      // Don't wait for the `config_ready` event if it has been cached previously.\n      if (this.cache.has(options.path)) {\n        return;\n      }\n      animationItem.addEventListener('config_ready', () => {\n        // See the comments below on why we're storing the animation data as a string.\n        this.cache.set(options.path, JSON.stringify(animationItem['animationData']));\n      });\n    }\n  }\n  transformOptions(options) {\n    if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {\n      return {\n        ...options,\n        path: undefined,\n        // Caretaker note: `lottie-web` cannot re-use the `animationData` object between animations, and we\n        // have to retrieve a new object each time an animation is created.\n        // https://github.com/airbnb/lottie-web#html\n        // See comments for the `animationData` property.\n        animationData: JSON.parse(this.cache.get(options.path))\n      };\n    } else {\n      return options;\n    }\n  }\n  isAnimationConfigWithPath(options) {\n    return typeof options.path === 'string';\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCacheableAnimationLoader_BaseFactory;\n      return function CacheableAnimationLoader_Factory(__ngFactoryType__) {\n        return (ɵCacheableAnimationLoader_BaseFactory || (ɵCacheableAnimationLoader_BaseFactory = i0.ɵɵgetInheritedFactory(CacheableAnimationLoader)))(__ngFactoryType__ || CacheableAnimationLoader);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: CacheableAnimationLoader,\n      factory: CacheableAnimationLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CacheableAnimationLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction provideCacheableAnimationLoader() {\n  return [{\n    provide: AnimationLoader,\n    useExisting: CacheableAnimationLoader\n  }];\n}\nfunction provideLottieOptions(options) {\n  return [{\n    provide: LOTTIE_OPTIONS,\n    useValue: options\n  }];\n}\nclass BaseDirective {\n  constructor() {\n    this.options = input(null);\n    this.containerClass = input(null);\n    this.styles = input(null);\n    /**\n     * `animationCreated` is dispatched after calling `loadAnimation`.\n     */\n    this.animationCreated = this.getAnimationItem();\n    /**\n     * `complete` is dispatched after completing the last frame.\n     */\n    this.complete = this.awaitAnimationItemAndStartListening('complete');\n    /**\n     * `loopComplete` is dispatched after completing the frame loop.\n     */\n    this.loopComplete = this.awaitAnimationItemAndStartListening('loopComplete');\n    /**\n     * `enterFrame` is dispatched after entering the new frame.\n     */\n    this.enterFrame = this.awaitAnimationItemAndStartListening('enterFrame');\n    /**\n     * `segmentStart` is dispatched when the new segment is adjusted.\n     */\n    this.segmentStart = this.awaitAnimationItemAndStartListening('segmentStart');\n    /**\n     * Original event name is `config_ready`. `config_ready` is dispatched\n     * after the needed renderer is configured.\n     */\n    this.configReady = this.awaitAnimationItemAndStartListening('config_ready');\n    /**\n     * Original event name is `data_ready`. `data_ready` is dispatched\n     * when all parts of the animation have been loaded.\n     */\n    this.dataReady = this.awaitAnimationItemAndStartListening('data_ready');\n    /**\n     * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched\n     * when elements have been added to the DOM.\n     */\n    this.domLoaded = this.awaitAnimationItemAndStartListening('DOMLoaded');\n    /**\n     * `destroy` will be dispatched when the component gets destroyed,\n     * it's handy for releasing resources.\n     */\n    this.destroy = this.awaitAnimationItemAndStartListening('destroy');\n    /**\n     * `error` will be dispatched if the Lottie player could not render\n     * some frame or parse config.\n     */\n    this.error = this.awaitAnimationItemAndStartListening('error');\n    this.ngZone = inject(NgZone);\n    this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n    this.animationLoader = inject(AnimationLoader);\n    this.loadAnimation$ = new Subject();\n    this.animationItem$ = new BehaviorSubject(null);\n    this.setupLoadAnimationListener();\n  }\n  ngOnDestroy() {\n    this.destroyAnimation();\n  }\n  loadAnimation(changes, container) {\n    this.ngZone.runOutsideAngular(() => this.loadAnimation$.next([changes, container]));\n  }\n  getAnimationItem() {\n    return defer(() => this.animationItem$).pipe(filter(animationItem => animationItem !== null));\n  }\n  awaitAnimationItemAndStartListening(name) {\n    return this.getAnimationItem().pipe(switchMap(animationItem =>\n    // `fromEvent` will try to call `removeEventListener` when `unsubscribe()` is invoked.\n    // The problem is that `ngOnDestroy()` is called before Angular unsubscribes from\n    // `@Output()` properties, thus `animationItem` will be `null` already, also `lottie-web`\n    // removes event listeners when calling `destroy()`.\n    new Observable(observer => {\n      this.ngZone.runOutsideAngular(() => {\n        animationItem.addEventListener(name, event => {\n          this.ngZone.runOutsideAngular(() => {\n            observer.next(event);\n          });\n        });\n      });\n    })));\n  }\n  setupLoadAnimationListener() {\n    const loadAnimation$ = this.loadAnimation$.pipe(filter(([changes]) => this.isBrowser && changes.options !== undefined));\n    loadAnimation$.pipe(switchMap(([changes, container]) => {\n      this.destroyAnimation();\n      return this.animationLoader.loadAnimation(this.animationLoader.resolveOptions(changes.options.currentValue, container));\n    }), takeUntilDestroyed()).subscribe(animationItem => {\n      this.ngZone.run(() => this.animationItem$.next(animationItem));\n    });\n  }\n  destroyAnimation() {\n    const animationItem = this.animationItem$.getValue();\n    // The `ng-lottie` component or the `lottie` directive can be destroyed\n    // before the `animationItem` is set, thus it will fail with\n    // `Cannot read property 'destroy' of null`.\n    // Potentially it can happen if the directive gets destroyed before change\n    // detection is run.\n    if (animationItem === null) {\n      return;\n    }\n    // `destroy()` will remove all events listeners.\n    animationItem.destroy();\n    this.animationItem$.next(null);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function BaseDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || BaseDirective)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: BaseDirective,\n      selectors: [[\"\", \"lottie\", \"\"]],\n      inputs: {\n        options: [1, \"options\"],\n        containerClass: [1, \"containerClass\"],\n        styles: [1, \"styles\"]\n      },\n      outputs: {\n        animationCreated: \"animationCreated\",\n        complete: \"complete\",\n        loopComplete: \"loopComplete\",\n        enterFrame: \"enterFrame\",\n        segmentStart: \"segmentStart\",\n        configReady: \"configReady\",\n        dataReady: \"dataReady\",\n        domLoaded: \"domLoaded\",\n        destroy: \"destroy\",\n        error: \"error\"\n      },\n      standalone: false\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BaseDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[lottie]'\n    }]\n  }], () => [], {\n    animationCreated: [{\n      type: Output\n    }],\n    complete: [{\n      type: Output\n    }],\n    loopComplete: [{\n      type: Output\n    }],\n    enterFrame: [{\n      type: Output\n    }],\n    segmentStart: [{\n      type: Output\n    }],\n    configReady: [{\n      type: Output\n    }],\n    dataReady: [{\n      type: Output\n    }],\n    domLoaded: [{\n      type: Output\n    }],\n    destroy: [{\n      type: Output\n    }],\n    error: [{\n      type: Output\n    }]\n  });\n})();\nclass LottieDirective extends BaseDirective {\n  constructor() {\n    super(...arguments);\n    this.host = inject(ElementRef);\n  }\n  ngOnChanges(changes) {\n    super.loadAnimation(changes, this.host.nativeElement);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵLottieDirective_BaseFactory;\n      return function LottieDirective_Factory(__ngFactoryType__) {\n        return (ɵLottieDirective_BaseFactory || (ɵLottieDirective_BaseFactory = i0.ɵɵgetInheritedFactory(LottieDirective)))(__ngFactoryType__ || LottieDirective);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: LottieDirective,\n      selectors: [[\"\", \"lottie\", \"\"]],\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[lottie]',\n      standalone: true\n    }]\n  }], null, null);\n})();\nclass LottieComponent extends BaseDirective {\n  constructor() {\n    super(...arguments);\n    this.width = input(null);\n    this.height = input(null);\n    this.container = null;\n  }\n  ngOnChanges(changes) {\n    super.loadAnimation(changes, this.container.nativeElement);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵLottieComponent_BaseFactory;\n      return function LottieComponent_Factory(__ngFactoryType__) {\n        return (ɵLottieComponent_BaseFactory || (ɵLottieComponent_BaseFactory = i0.ɵɵgetInheritedFactory(LottieComponent)))(__ngFactoryType__ || LottieComponent);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: LottieComponent,\n      selectors: [[\"ng-lottie\"]],\n      viewQuery: function LottieComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        }\n      },\n      inputs: {\n        width: [1, \"width\"],\n        height: [1, \"height\"]\n      },\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n      decls: 2,\n      vars: 6,\n      consts: [[\"container\", \"\"], [3, \"ngStyle\", \"ngClass\"]],\n      template: function LottieComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"div\", 1, 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"width\", ctx.width() || \"100%\")(\"height\", ctx.height() || \"100%\");\n          i0.ɵɵproperty(\"ngStyle\", ctx.styles())(\"ngClass\", ctx.containerClass());\n        }\n      },\n      dependencies: [NgStyle, NgClass],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ng-lottie',\n      template: `\n    <div\n      #container\n      [style.width]=\"width() || '100%'\"\n      [style.height]=\"height() || '100%'\"\n      [ngStyle]=\"styles()\"\n      [ngClass]=\"containerClass()\"\n    ></div>\n  `,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      standalone: true,\n      imports: [NgStyle, NgClass]\n    }]\n  }], null, {\n    container: [{\n      type: ViewChild,\n      args: ['container', {\n        static: true\n      }]\n    }]\n  });\n})();\nfunction transformAnimationFilenameToKey(animation) {\n  const [animationName] = animation.split('.json');\n  return `animation-${animationName}`;\n}\nclass LottieTransferState {\n  constructor(transferState) {\n    this.transferState = transferState;\n  }\n  get(animation) {\n    const animationKey = transformAnimationFilenameToKey(animation);\n    const stateKey = makeStateKey(animationKey);\n    return this.transferState.get(stateKey, null);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function LottieTransferState_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || LottieTransferState)(i0.ɵɵinject(i0.TransferState));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LottieTransferState,\n      factory: LottieTransferState.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieTransferState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i0.TransferState\n  }], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AnimationLoader, BaseDirective, LottieComponent, LottieDirective, LottieTransferState, provideCacheableAnimationLoader, provideLottieOptions, transformAnimationFilenameToKey, CacheableAnimationLoader as ɵCacheableAnimationLoader, LOTTIE_OPTIONS as ɵLOTTIE_OPTIONS };\n"],"mappings":"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","names":["player"],"x_google_ignoreList":[0,1]}